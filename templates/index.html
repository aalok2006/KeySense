<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Virtual Keyboard - Web</title>
    <style>
        /* General Body Styles */
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            margin: 0; /* Remove default margin */
            padding-top: 30px; /* Add some padding at the top */
            background-color: #f0f0f5; /* Light bluish-gray background */
            color: #333; /* Darker text for contrast */
            min-height: 100vh; /* Ensure body takes full height */
            box-sizing: border-box; /* Include padding in element's total width and height */
        }

        h1 {
            color: #2c3e50; /* Darker title */
            margin-bottom: 25px;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.1);
        }

        /* Video Container and Canvas */
        #videoContainer {
            position: relative;
            width: 640px;
            height: 480px;
            border: 2px solid #ccc; /* Softer border */
            border-radius: 8px; /* Slightly rounded corners */
            overflow: hidden; /* Hide any overflow */
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1); /* Subtle shadow */
            background-color: #fff; /* White background for the container */
        }

        #videoElement {
            width: 100%;
            height: 100%;
            object-fit: cover; /* Ensure video covers the area */
            transform: scaleX(-1); /* Mirror the video for typical webcam view */
            position: absolute; /* Position correctly within container */
        }

        #overlayCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            /* REMOVED: pointer-events: none; -- We need canvas to capture mouse events */
        }

        /* Output Textarea */
        #output {
            width: 640px;
            min-height: 100px;
            margin-top: 30px;
            padding: 15px;
            font-size: 1.4em;
            border: 2px solid #ccc; /* Softer border */
            border-radius: 8px;
            box-shadow: inset 0 2px 5px rgba(0, 0, 0, 0.05); /* Inner shadow */
            resize: vertical; /* Allow vertical resizing */
            background-color: #fff; /* White background */
            color: #333;
            font-family: 'Consolas', 'Monaco', monospace; /* Monospaced font for text output */
        }

        #output::placeholder {
            color: #aaa;
        }

        /* Information Text */
        .button-info {
            margin-top: 20px;
            font-size: 0.95em;
            color: #666;
            font-style: italic;
            text-align: center;
            max-width: 600px;
            line-height: 1.5;
            padding-bottom: 30px; /* Add padding at the bottom for better spacing */
        }
    </style>
</head>
<body>
    <h1>AI Virtual Keyboard (Web Demo)</h1>
    <div id="videoContainer">
        <video id="videoElement" autoplay playsinline></video>
        <canvas id="overlayCanvas"></canvas>
    </div>
    <textarea id="output" placeholder="Typed text will appear here..."></textarea>
    <div class="button-info">
        <p><strong>Note:</strong> This demo draws a virtual keyboard and simulates hover/click effects on the canvas. For actual AI hand tracking, you'll integrate the drawing logic within your MediaPipe (or similar) framework.</p>
        <p>Click by bringing your index and middle fingers close together over a key (or use your mouse to simulate clicks for this demo).</p>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const videoElement = document.getElementById('videoElement');
            const overlayCanvas = document.getElementById('overlayCanvas');
            const outputTextArea = document.getElementById('output');
            const ctx = overlayCanvas.getContext('2d');

            let keyboardKeys = [];
            let currentHoveredKey = null; // Key that is currently under the mouse/finger
            let currentActiveKey = null; // Key that is currently "pressed"

            // Define Neon Colors
            const NEON_BASE_COLOR = 'rgba(0, 255, 255, 0.6)';      // Cyan with transparency
            const NEON_HOVER_COLOR = 'rgba(0, 255, 255, 0.9)';     // Brighter cyan on hover
            const NEON_PRESS_COLOR = 'rgb(255, 100, 255)';         // Magenta on press
            const NEON_TEXT_COLOR = '#fff';                        // White text on keys

            // Animation Constants
            const ANIM_DURATION_HOVER = 150; // ms for hover/unhover transition
            const ANIM_DURATION_PRESS = 80;  // ms for press down transition
            const ANIM_DURATION_RELEASE = 150; // ms for press release transition

            const GLOW_BASE = 10;           // Base glow blur amount
            const GLOW_HOVER = 18;          // Glow blur on hover
            const GLOW_PRESS = 25;          // Glow blur on press
            const GLOW_PULSE_AMOUNT = 5;    // How much the glow pulses from base
            const GLOW_PULSE_SPEED = 0.002; // How fast the glow pulses (higher for faster)

            const KEY_SCALE_BASE = 1.0;     // Base key scale
            const KEY_SCALE_PRESS = 0.95;   // Slightly shrink key on press
            const KEY_SCALE_HOVER = 1.0;    // No scale change on hover by default

            // --- Keyboard Layout Definition ---
            const keyWidth = 60;
            const keyHeight = 50;
            const keyMargin = 10;
            // Center keyboard horizontally, position near bottom
            let startX, startY; // Will be calculated after canvas dimensions are known

            // --- Helper Functions for Animation ---

            // Helper to parse RGBA string to array [r, g, b, a]
            function parseRgba(rgba) {
                const parts = rgba.match(/\d+(\.\d+)?/g).map(Number);
                if (rgba.includes('rgba')) {
                    return parts.length === 4 ? parts : [parts[0], parts[1], parts[2], 1]; // Default alpha to 1 if missing for rgb()
                }
                return [parts[0], parts[1], parts[2], 1]; // For rgb()
            }

            // Helper to interpolate colors (linear interpolation for each RGBA component)
            function interpolateRgba(rgba1, rgba2, progress) {
                const c1 = parseRgba(rgba1);
                const c2 = parseRgba(rgba2);
                const r = c1[0] + (c2[0] - c1[0]) * progress;
                const g = c1[1] + (c2[1] - c1[1]) * progress;
                const b = c1[2] + (c2[2] - c1[2]) * progress;
                const a = c1[3] + (c2[3] - c1[3]) * progress;
                return `rgba(${Math.round(r)}, ${Math.round(g)}, ${Math.round(b)}, ${a.toFixed(2)})`;
            }

            // Helper for linear interpolation (for numbers like blur or scale)
            function lerp(start, end, progress) {
                return start + (end - start) * progress;
            }

            function setupKeyboardLayout() {
                // Calculate start positions based on canvas size
                startX = (overlayCanvas.width - (10 * keyWidth + 9 * keyMargin)) / 2;
                startY = overlayCanvas.height - 4 * (keyHeight + keyMargin) - 20; // 4 rows + some bottom margin

                const keys = [
                    ['Q', 'W', 'E', 'R', 'T', 'Y', 'U', 'I', 'O', 'P'],
                    ['A', 'S', 'D', 'F', 'G', 'H', 'J', 'K', 'L', ''],
                    ['Z', 'X', 'C', 'V', 'B', 'N', 'M', ',', '.', ''],
                    ['SPACE', 'BACKSPACE']
                ];

                keyboardKeys = [];
                let yOffset = 0;
                keys.forEach((row, rowIndex) => {
                    let xOffset = 0;
                    if (rowIndex === 1) xOffset += (keyWidth + keyMargin) / 2; // Offset for ASDF row
                    if (rowIndex === 2) xOffset += (keyWidth + keyMargin) / 2; // Offset for ZXCV row

                    row.forEach(keyText => {
                        let currentKeyWidth = keyWidth;
                        if (keyText === 'SPACE') currentKeyWidth = keyWidth * 5 + keyMargin * 4;
                        if (keyText === 'BACKSPACE') currentKeyWidth = keyWidth * 2 + keyMargin;
                        if (keyText === '') return; // Skip empty keys in layout

                        keyboardKeys.push({
                            char: keyText,
                            x: startX + xOffset,
                            y: startY + yOffset,
                            width: currentKeyWidth,
                            height: keyHeight,
                            isHovered: false, // Tracks if mouse/finger is currently over the key
                            isActive: false,  // Tracks if the key is currently "pressed"

                            // Animation properties for smooth transitions
                            _fillColor: NEON_BASE_COLOR,        // Current color being drawn
                            _targetFillColor: NEON_BASE_COLOR,  // Color to animate towards
                            _startFillColor: NEON_BASE_COLOR,   // Starting color for current animation

                            _shadowBlur: GLOW_BASE,             // Current glow blur being drawn
                            _targetShadowBlur: GLOW_BASE,       // Glow blur to animate towards
                            _startShadowBlur: GLOW_BASE,        // Starting blur for current animation

                            _scale: KEY_SCALE_BASE,             // Current scale being drawn
                            _targetScale: KEY_SCALE_BASE,       // Scale to animate towards
                            _startScale: KEY_SCALE_BASE,        // Starting scale for current animation

                            _animationProgress: 1,  // Progress of current animation (0 to 1). 1 means animation complete.
                            _animationStartTime: 0, // Timestamp when current animation started
                            _animationDuration: 0,  // Duration of current animation
                        });
                        xOffset += currentKeyWidth + keyMargin;
                    });
                    yOffset += keyHeight + keyMargin;
                });
            }

            // --- Drawing Functions ---

            function drawKey(key) {
                ctx.save(); // Save current context state (important for transformations)

                // Translate context to the center of the key, apply scale, then translate back
                // This ensures scaling happens from the key's center.
                ctx.translate(key.x + key.width / 2, key.y + key.height / 2);
                ctx.scale(key._scale, key._scale);
                ctx.translate(-(key.x + key.width / 2), -(key.y + key.height / 2));

                ctx.beginPath();
                ctx.roundRect(key.x, key.y, key.width, key.height, 8); // Rounded rectangle

                ctx.fillStyle = key._fillColor;
                ctx.fill();

                // Apply glow effect
                ctx.shadowColor = key._fillColor; // Glow color matches fill
                ctx.shadowBlur = key._shadowBlur;
                ctx.shadowOffsetX = 0;
                ctx.shadowOffsetY = 0;

                ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)'; // Lighter border for neon effect
                ctx.lineWidth = 1;
                ctx.stroke();

                // Reset shadow for text drawing (text should not have shadow)
                ctx.shadowColor = 'transparent';
                ctx.shadowBlur = 0;

                ctx.fillStyle = NEON_TEXT_COLOR;
                ctx.font = `bold ${key.char === 'SPACE' || key.char === 'BACKSPACE' ? '1.1em' : '1.5em'} Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                // Text position is automatically centered due to context transformations
                ctx.fillText(key.char, key.x + key.width / 2, key.y + key.height / 2);

                ctx.restore(); // Restore context state (undoes translate and scale)
            }

            function drawKeyboard() {
                // Clear the entire canvas for each frame.
                // In a real application with dynamic video, you might optimize this
                // to only redraw specific areas or use a separate canvas for video.
                ctx.clearRect(0, 0, overlayCanvas.width, overlayCanvas.height);
                keyboardKeys.forEach(key => drawKey(key));
            }

            // --- Animation Loop ---
            let animationFrameId = null; // To store requestAnimationFrame ID

            function updateAnimations(currentTime) {
                keyboardKeys.forEach(key => {
                    // Update key's animation properties if an animation is in progress
                    if (key._animationProgress < 1) {
                        const elapsed = currentTime - key._animationStartTime;
                        key._animationProgress = Math.min(1, elapsed / key._animationDuration);

                        key._fillColor = interpolateRgba(key._startFillColor, key._targetFillColor, key._animationProgress);
                        key._shadowBlur = lerp(key._startShadowBlur, key._targetShadowBlur, key._animationProgress);
                        key._scale = lerp(key._startScale, key._targetScale, key._animationProgress);
                    }

                    // Apply pulsating glow for keys that are at their base state
                    // (not hovered, not active, and no active animation for hover/press/release)
                    if (!key.isHovered && !key.isActive && key._animationProgress >= 1) {
                        const pulse = Math.sin(currentTime * GLOW_PULSE_SPEED) * GLOW_PULSE_AMOUNT;
                        key._shadowBlur = GLOW_BASE + pulse;
                    }
                });
            }

            function renderLoop(currentTime) {
                updateAnimations(currentTime); // Update all key properties based on current time
                drawKeyboard(); // Redraw the keyboard with updated properties
                animationFrameId = requestAnimationFrame(renderLoop); // Continue the loop
            }


            // --- Interaction Logic (Simulated for Demo using Mouse Events) ---

            function isPointInKey(x, y, key) {
                return x > key.x && x < key.x + key.width &&
                       y > key.y && y < key.y + key.height;
            }

            // Mouse Hover Simulation
            overlayCanvas.addEventListener('mousemove', (event) => {
                const rect = overlayCanvas.getBoundingClientRect();
                const mouseX = event.clientX - rect.left;
                const mouseY = event.clientY - rect.top;

                let foundHovered = false;

                for (let i = 0; i < keyboardKeys.length; i++) {
                    const key = keyboardKeys[i];
                    if (isPointInKey(mouseX, mouseY, key)) {
                        // If a key is now hovered AND it's not currently active (pressed)
                        if (!key.isHovered && !key.isActive) {
                            key.isHovered = true;
                            // Start hover animation
                            key._startFillColor = key._fillColor;
                            key._targetFillColor = NEON_HOVER_COLOR;
                            key._startShadowBlur = key._shadowBlur;
                            key._targetShadowBlur = GLOW_HOVER;
                            key._startScale = key._scale;
                            key._targetScale = KEY_SCALE_HOVER;
                            key._animationStartTime = performance.now();
                            key._animationDuration = ANIM_DURATION_HOVER;
                            key._animationProgress = 0;
                        }
                        foundHovered = true;
                        // If a new key is hovered, ensure the previously hovered key unhovers (if not active)
                        if (currentHoveredKey && currentHoveredKey !== key && !currentHoveredKey.isActive) {
                             currentHoveredKey.isHovered = false;
                             currentHoveredKey._startFillColor = currentHoveredKey._fillColor;
                             currentHoveredKey._targetFillColor = NEON_BASE_COLOR;
                             currentHoveredKey._startShadowBlur = currentHoveredKey._shadowBlur;
                             currentHoveredKey._targetShadowBlur = GLOW_BASE;
                             currentHoveredKey._startScale = currentHoveredKey._scale;
                             currentHoveredKey._targetScale = KEY_SCALE_BASE;
                             currentHoveredKey._animationStartTime = performance.now();
                             currentHoveredKey._animationDuration = ANIM_DURATION_HOVER;
                             currentHoveredKey._animationProgress = 0;
                        }
                        currentHoveredKey = key; // Update current hovered key
                        break;
                    } else {
                        // If mouse moves off a key, and it was hovered and not active, unhover it
                        if (key.isHovered && !key.isActive) {
                            key.isHovered = false;
                            // Start unhover animation
                            key._startFillColor = key._fillColor;
                            key._targetFillColor = NEON_BASE_COLOR;
                            key._startShadowBlur = key._shadowBlur;
                            key._targetShadowBlur = GLOW_BASE;
                            key._startScale = key._scale;
                            key._targetScale = KEY_SCALE_BASE;
                            key._animationStartTime = performance.now();
                            key._animationDuration = ANIM_DURATION_HOVER;
                            key._animationProgress = 0;
                            if (currentHoveredKey === key) { // Clear currentHoveredKey if it's this one
                                currentHoveredKey = null;
                            }
                        }
                    }
                }
                // If no key is currently hovered, and there was a previous one, unhover it
                if (!foundHovered && currentHoveredKey && !currentHoveredKey.isActive) {
                    currentHoveredKey.isHovered = false;
                    currentHoveredKey._startFillColor = currentHoveredKey._fillColor;
                    currentHoveredKey._targetFillColor = NEON_BASE_COLOR;
                    currentHoveredKey._startShadowBlur = currentHoveredKey._shadowBlur;
                    currentHoveredKey._targetShadowBlur = GLOW_BASE;
                    currentHoveredKey._startScale = currentHoveredKey._scale;
                    currentHoveredKey._targetScale = KEY_SCALE_BASE;
                    currentHoveredKey._animationStartTime = performance.now();
                    currentHoveredKey._animationDuration = ANIM_DURATION_HOVER;
                    currentHoveredKey._animationProgress = 0;
                    currentHoveredKey = null;
                }
            });

            // Mouse Click Simulation
            overlayCanvas.addEventListener('mousedown', (event) => {
                const rect = overlayCanvas.getBoundingClientRect();
                const mouseX = event.clientX - rect.left;
                const mouseY = event.clientY - rect.top;

                for (let i = 0; i < keyboardKeys.length; i++) {
                    const key = keyboardKeys[i];
                    if (isPointInKey(mouseX, mouseY, key)) {
                        if (!key.isActive) { // Only animate if not already active
                            key.isActive = true;
                            currentActiveKey = key; // Keep track of the currently pressed key

                            // Start press animation
                            key._startFillColor = key._fillColor;
                            key._targetFillColor = NEON_PRESS_COLOR;
                            key._startShadowBlur = key._shadowBlur;
                            key._targetShadowBlur = GLOW_PRESS;
                            key._startScale = key._scale;
                            key._targetScale = KEY_SCALE_PRESS;
                            key._animationStartTime = performance.now();
                            key._animationDuration = ANIM_DURATION_PRESS;
                            key._animationProgress = 0;

                            typeCharacter(key.char); // Simulate typing
                        }
                        break;
                    }
                }
            });

            overlayCanvas.addEventListener('mouseup', () => {
                if (currentActiveKey) {
                    currentActiveKey.isActive = false;
                    // Start release animation
                    currentActiveKey._startFillColor = currentActiveKey._fillColor;
                    // If still hovered (mouse is over it), animate back to hover state, else to base state
                    currentActiveKey._targetFillColor = currentActiveKey.isHovered ? NEON_HOVER_COLOR : NEON_BASE_COLOR;
                    currentActiveKey._startShadowBlur = currentActiveKey._shadowBlur;
                    currentActiveKey._targetShadowBlur = currentActiveKey.isHovered ? GLOW_HOVER : GLOW_BASE;
                    currentActiveKey._startScale = currentActiveKey._scale;
                    currentActiveKey._targetScale = KEY_SCALE_BASE; // Return to normal scale
                    currentActiveKey._animationStartTime = performance.now();
                    currentActiveKey._animationDuration = ANIM_DURATION_RELEASE;
                    currentActiveKey._animationProgress = 0;

                    currentActiveKey = null; // Clear reference
                }
            });


            // Function to simulate typing into the textarea
            function typeCharacter(char) {
                if (char === 'SPACE') {
                    outputTextArea.value += ' ';
                } else if (char === 'BACKSPACE') {
                    outputTextArea.value = outputTextArea.value.slice(0, -1);
                } else {
                    outputTextArea.value += char;
                }
                // Scroll to bottom
                outputTextArea.scrollTop = outputTextArea.scrollHeight;
            }


            // --- Video Stream Setup ---

            function startVideoStream() {
                navigator.mediaDevices.getUserMedia({ video: true })
                    .then(stream => {
                        videoElement.srcObject = stream;
                        videoElement.onloadedmetadata = () => {
                            videoElement.play();
                            // Set canvas dimensions to match video
                            overlayCanvas.width = videoElement.videoWidth;
                            overlayCanvas.height = videoElement.videoHeight;
                            // Re-setup keyboard layout based on new canvas size
                            setupKeyboardLayout();
                            // Start the animation loop after setting up the keyboard
                            animationFrameId = requestAnimationFrame(renderLoop);
                        };
                    })
                    .catch(err => {
                        console.error('Error accessing webcam:', err);
                        alert('Could not start webcam. Please ensure camera access is granted.');
                        // Fallback: draw keyboard even without video for testing
                        // Set a default size for canvas if video fails
                        overlayCanvas.width = 640;
                        overlayCanvas.height = 480;
                        setupKeyboardLayout();
                        // Start animation loop even without video
                        animationFrameId = requestAnimationFrame(renderLoop);
                    });
            }

            // Initialize
            startVideoStream();

            // Clear any pending animation frames if the user navigates away or closes the page
            window.addEventListener('beforeunload', () => {
                if (animationFrameId) {
                    cancelAnimationFrame(animationFrameId);
                }
            });

            // --- Integration with Real Hand Tracking (Conceptual) ---
            // If you're using MediaPipe Hands, your drawing loop would look something like this:
            /*
            // Assuming 'hands' and 'camera' objects are initialized from MediaPipe setup.
            // Example:
            // const hands = new Hands({locateFile: (file) => { ... }});
            // const camera = new Camera(videoElement, { onFrame: async () => { await hands.send({ image: videoElement }); }});
            // camera.start();

            hands.onResults((results) => {
                // Determine hand landmark positions (e.g., index finger tip)
                // Determine click gestures (e.g., index and middle finger tips close)

                // Update keyboard key states (isHovered, isActive) based on hand data.
                // This would replace the mousemove/mousedown/mouseup event listeners.
                // Example:
                // const indexFingerTip = handLandmarks[8];
                // const fingerX = indexFingerTip.x * overlayCanvas.width;
                // const fingerY = indexFingerTip.y * overlayCanvas.height;
                // for (const key of keyboardKeys) {
                //     const wasHovered = key.isHovered;
                //     key.isHovered = isPointInKey(fingerX, fingerY, key);
                //     if (key.isHovered && !wasHovered && !key.isActive) {
                //         // Trigger hover animation for key
                //         // (Similar to mousemove logic in this demo, but for hand tracking)
                //     } else if (!key.isHovered && wasHovered && !key.isActive) {
                //         // Trigger unhover animation for key
                //     }

                //     const isClickGesture = /* logic to detect click gesture */;
                //     if (key.isHovered && isClickGesture && !key.isActive) {
                //         key.isActive = true;
                //         // Trigger press animation
                //         typeCharacter(key.char);
                //         // Set a timeout to release the key after a brief moment (e.g., 200ms)
                //         setTimeout(() => {
                //             key.isActive = false;
                //             // Trigger release animation
                //         }, 200);
                //     }
                // }

                // The `updateAnimations` and `renderLoop` functions would then automatically
                // pick up these state changes and animate the keys smoothly.
                // You would NOT call requestAnimationFrame here, as the MediaPipe loop
                // (camera.onFrame or hands.onResults) serves as the rendering loop.
                // So, you would call `updateAnimations` and `drawKeyboard` directly inside `onResults`.
                // updateAnimations(performance.now());
                // drawKeyboard();
            });
            */
        });
    </script>
</body>
</html>
